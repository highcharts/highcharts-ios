{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.4.1 (2024-04-04)\n *\n * Marker clusters module for Highcharts\n *\n * (c) 2010-2024 Wojciech Chmiel\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/marker-clusters', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusterDefaults.js', [], function () {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Options for marker clusters, the concept of sampling the data\n         * values into larger blocks in order to ease readability and\n         * increase performance of the JavaScript charts.\n         *\n         * Note: marker clusters module is not working with `boost`\n         * and `draggable-points` modules.\n         *\n         * The marker clusters feature requires the marker-clusters.js\n         * file to be loaded, found in the modules directory of the download\n         * package, or online at [code.highcharts.com/modules/marker-clusters.js\n         * ](code.highcharts.com/modules/marker-clusters.js).\n         *\n         * @sample maps/marker-clusters/europe\n         *         Maps marker clusters\n         * @sample highcharts/marker-clusters/basic\n         *         Scatter marker clusters\n         * @sample maps/marker-clusters/optimized-kmeans\n         *         Marker clusters with colorAxis\n         *\n         * @product      highcharts highmaps\n         * @since 8.0.0\n         * @optionparent plotOptions.scatter.cluster\n         *\n         * @private\n         */\n        var cluster = {\n            /**\n             * Whether to enable the marker-clusters module.\n             *\n             * @sample maps/marker-clusters/basic\n             *         Maps marker clusters\n             * @sample highcharts/marker-clusters/basic\n             *         Scatter marker clusters\n             */\n            enabled: false,\n            /**\n             * When set to `false` prevent cluster overlapping - this option\n             * works only when `layoutAlgorithm.type = \"grid\"`.\n             *\n             * @sample highcharts/marker-clusters/grid\n             *         Prevent overlapping\n             */\n            allowOverlap: true,\n            /**\n             * Options for the cluster marker animation.\n             * @type    {boolean|Partial<Highcharts.AnimationOptionsObject>}\n             * @default { \"duration\": 500 }\n             */\n            animation: {\n                /** @ignore-option */\n                duration: 500\n            },\n            /**\n             * Zoom the plot area to the cluster points range when a cluster is clicked.\n             */\n            drillToCluster: true,\n            /**\n             * The minimum amount of points to be combined into a cluster.\n             * This value has to be greater or equal to 2.\n             *\n             * @sample highcharts/marker-clusters/basic\n             *         At least three points in the cluster\n             */\n            minimumClusterSize: 2,\n            /**\n             * Options for layout algorithm. Inside there\n             * are options to change the type of the algorithm, gridSize,\n             * distance or iterations.\n             */\n            layoutAlgorithm: {\n                /**\n                 * Type of the algorithm used to combine points into a cluster.\n                 * There are three available algorithms:\n                 *\n                 * 1) `grid` - grid-based clustering technique. Points are assigned\n                 * to squares of set size depending on their position on the plot\n                 * area. Points inside the grid square are combined into a cluster.\n                 * The grid size can be controlled by `gridSize` property\n                 * (grid size changes at certain zoom levels).\n                 *\n                 * 2) `kmeans` - based on K-Means clustering technique. In the\n                 * first step, points are divided using the grid method (distance\n                 * property is a grid size) to find the initial amount of clusters.\n                 * Next, each point is classified by computing the distance between\n                 * each cluster center and that point. When the closest cluster\n                 * distance is lower than distance property set by a user the point\n                 * is added to this cluster otherwise is classified as `noise`. The\n                 * algorithm is repeated until each cluster center not change its\n                 * previous position more than one pixel. This technique is more\n                 * accurate but also more time consuming than the `grid` algorithm,\n                 * especially for big datasets.\n                 *\n                 * 3) `optimizedKmeans` - based on K-Means clustering technique. This\n                 * algorithm uses k-means algorithm only on the chart initialization\n                 * or when chart extremes have greater range than on initialization.\n                 * When a chart is redrawn the algorithm checks only clustered points\n                 * distance from the cluster center and rebuild it when the point is\n                 * spaced enough to be outside the cluster. It provides performance\n                 * improvement and more stable clusters position yet can be used rather\n                 * on small and sparse datasets.\n                 *\n                 * By default, the algorithm depends on visible quantity of points\n                 * and `kmeansThreshold`. When there are more visible points than the\n                 * `kmeansThreshold` the `grid` algorithm is used, otherwise `kmeans`.\n                 *\n                 * The custom clustering algorithm can be added by assigning a callback\n                 * function as the type property. This function takes an array of\n                 * `processedXData`, `processedYData`, `processedXData` indexes and\n                 * `layoutAlgorithm` options as arguments and should return an object\n                 * with grouped data.\n                 *\n                 * The algorithm should return an object like that:\n                 * <pre>{\n                 *  clusterId1: [{\n                 *      x: 573,\n                 *      y: 285,\n                 *      index: 1 // point index in the data array\n                 *  }, {\n                 *      x: 521,\n                 *      y: 197,\n                 *      index: 2\n                 *  }],\n                 *  clusterId2: [{\n                 *      ...\n                 *  }]\n                 *  ...\n                 * }</pre>\n                 *\n                 * `clusterId` (example above - unique id of a cluster or noise)\n                 * is an array of points belonging to a cluster. If the\n                 * array has only one point or fewer points than set in\n                 * `cluster.minimumClusterSize` it won't be combined into a cluster.\n                 *\n                 * @sample maps/marker-clusters/optimized-kmeans\n                 *         Optimized K-Means algorithm\n                 * @sample highcharts/marker-clusters/kmeans\n                 *         K-Means algorithm\n                 * @sample highcharts/marker-clusters/grid\n                 *         Grid algorithm\n                 * @sample maps/marker-clusters/custom-alg\n                 *         Custom algorithm\n                 *\n                 * @type {string|Function}\n                 * @see [cluster.minimumClusterSize](#plotOptions.scatter.cluster.minimumClusterSize)\n                 * @apioption plotOptions.scatter.cluster.layoutAlgorithm.type\n                 */\n                /**\n                 * When `type` is set to the `grid`,\n                 * `gridSize` is a size of a grid square element either as a number\n                 * defining pixels, or a percentage defining a percentage\n                 * of the plot area width.\n                 *\n                 * @type    {number|string}\n                 */\n                gridSize: 50,\n                /**\n                 * When `type` is set to `kmeans`,\n                 * `iterations` are the number of iterations that this algorithm will be\n                 * repeated to find clusters positions.\n                 *\n                 * @type    {number}\n                 * @apioption plotOptions.scatter.cluster.layoutAlgorithm.iterations\n                 */\n                /**\n                 * When `type` is set to `kmeans`,\n                 * `distance` is a maximum distance between point and cluster center\n                 * so that this point will be inside the cluster. The distance\n                 * is either a number defining pixels or a percentage\n                 * defining a percentage of the plot area width.\n                 *\n                 * @type    {number|string}\n                 */\n                distance: 40,\n                /**\n                 * When `type` is set to `undefined` and there are more visible points\n                 * than the kmeansThreshold the `grid` algorithm is used to find\n                 * clusters, otherwise `kmeans`. It ensures good performance on\n                 * large datasets and better clusters arrangement after the zoom.\n                 */\n                kmeansThreshold: 100\n            },\n            /**\n             * Options for the cluster marker.\n             * @type      {Highcharts.PointMarkerOptionsObject}\n             * @extends   plotOptions.series.marker\n             * @excluding enabledThreshold, states\n             */\n            marker: {\n                /** @internal */\n                symbol: 'cluster',\n                /** @internal */\n                radius: 15,\n                /** @internal */\n                lineWidth: 0,\n                /** @internal */\n                lineColor: \"#ffffff\" /* Palette.backgroundColor */\n            },\n            /**\n             * Fires when the cluster point is clicked and `drillToCluster` is enabled.\n             * One parameter, `event`, is passed to the function. The default action\n             * is to zoom to the cluster points range. This can be prevented\n             * by calling `event.preventDefault()`.\n             *\n             * @type      {Highcharts.MarkerClusterDrillCallbackFunction}\n             * @product   highcharts highmaps\n             * @see [cluster.drillToCluster](#plotOptions.scatter.cluster.drillToCluster)\n             * @apioption plotOptions.scatter.cluster.events.drillToCluster\n             */\n            /**\n             * An array defining zones within marker clusters.\n             *\n             * In styled mode, the color zones are styled with the\n             * `.highcharts-cluster-zone-{n}` class, or custom\n             * classed from the `className`\n             * option.\n             *\n             * @sample highcharts/marker-clusters/basic\n             *         Marker clusters zones\n             * @sample maps/marker-clusters/custom-alg\n             *         Zones on maps\n             *\n             * @type      {Array<*>}\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones\n             */\n            /**\n             * Styled mode only. A custom class name for the zone.\n             *\n             * @sample highcharts/css/color-zones/\n             *         Zones styled by class name\n             *\n             * @type      {string}\n             * @apioption plotOptions.scatter.cluster.zones.className\n             */\n            /**\n             * Settings for the cluster marker belonging to the zone.\n             *\n             * @see [cluster.marker](#plotOptions.scatter.cluster.marker)\n             * @extends   plotOptions.scatter.cluster.marker\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones.marker\n             */\n            /**\n             * The value where the zone starts.\n             *\n             * @type      {number}\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones.from\n             */\n            /**\n             * The value where the zone ends.\n             *\n             * @type      {number}\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones.to\n             */\n            /**\n             * The fill color of the cluster marker in hover state. When\n             * `undefined`, the series' or point's fillColor for normal\n             * state is used.\n             *\n             * @type      {Highcharts.ColorType}\n             * @apioption plotOptions.scatter.cluster.states.hover.fillColor\n             */\n            /**\n             * Options for the cluster data labels.\n             * @type    {Highcharts.DataLabelsOptions}\n             */\n            dataLabels: {\n                /** @internal */\n                enabled: true,\n                /** @internal */\n                format: '{point.clusterPointsAmount}',\n                /** @internal */\n                verticalAlign: 'middle',\n                /** @internal */\n                align: 'center',\n                /** @internal */\n                style: {\n                    color: 'contrast'\n                },\n                /** @internal */\n                inside: true\n            }\n        };\n        var tooltip = {\n            /**\n             * The HTML of the cluster point's in the tooltip. Works only with\n             * marker-clusters module and analogously to\n             * [pointFormat](#tooltip.pointFormat).\n             *\n             * The cluster tooltip can be also formatted using\n             * `tooltip.formatter` callback function and `point.isCluster` flag.\n             *\n             * @sample highcharts/marker-clusters/grid\n             *         Format tooltip for cluster points.\n             *\n             * @sample maps/marker-clusters/europe/\n             *         Format tooltip for clusters using tooltip.formatter\n             *\n             * @type      {string}\n             * @default   Clustered points: {point.clusterPointsAmount}\n             * @apioption tooltip.clusterFormat\n             */\n            clusterFormat: '<span>Clustered points: ' +\n                '{point.clusterPointsAmount}</span><br/>'\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var MarkerClusterDefaults = {\n            cluster: cluster,\n            tooltip: tooltip\n        };\n\n        return MarkerClusterDefaults;\n    });\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusterScatter.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Extensions/MarkerClusters/MarkerClusterDefaults.js'], _modules['Core/Utilities.js']], function (A, MarkerClusterDefaults, U) {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var animObject = A.animObject;\n        var clusterDefaults = MarkerClusterDefaults.cluster;\n        var addEvent = U.addEvent, defined = U.defined, error = U.error, isArray = U.isArray, isFunction = U.isFunction, isObject = U.isObject, isNumber = U.isNumber, merge = U.merge, objectEach = U.objectEach, relativeLength = U.relativeLength, syncTimeout = U.syncTimeout;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var markerClusterAlgorithms = {\n            grid: function (dataX, dataY, dataIndexes, options) {\n                var series = this, grid = {}, gridOffset = this.getGridOffset();\n                var x, y, gridX, gridY, key, i;\n                var scaledGridSize = series.getScaledGridSize(options);\n                for (i = 0; i < dataX.length; i++) {\n                    var p = valuesToPixels(series, { x: dataX[i], y: dataY[i] });\n                    x = p.x - gridOffset.plotLeft;\n                    y = p.y - gridOffset.plotTop;\n                    gridX = Math.floor(x / scaledGridSize);\n                    gridY = Math.floor(y / scaledGridSize);\n                    key = gridY + '-' + gridX;\n                    if (!grid[key]) {\n                        grid[key] = [];\n                    }\n                    grid[key].push({\n                        dataIndex: dataIndexes[i],\n                        x: dataX[i],\n                        y: dataY[i]\n                    });\n                }\n                return grid;\n            },\n            kmeans: function (dataX, dataY, dataIndexes, options) {\n                var series = this, clusters = [], noise = [], group = {}, pointMaxDistance = options.processedDistance ||\n                    clusterDefaults.layoutAlgorithm.distance, iterations = options.iterations, \n                // Max pixel difference beetwen new and old cluster position.\n                maxClusterShift = 1;\n                var currentIteration = 0, repeat = true, pointX = 0, pointY = 0, tempPos, pointClusterDistance = [];\n                options.processedGridSize = options.processedDistance;\n                // Use grid method to get groupedData object.\n                var groupedData = series.markerClusterAlgorithms ?\n                    series.markerClusterAlgorithms.grid.call(series, dataX, dataY, dataIndexes, options) : {};\n                // Find clusters amount and its start positions\n                // based on grid grouped data.\n                for (var key in groupedData) {\n                    if (groupedData[key].length > 1) {\n                        tempPos = getClusterPosition(groupedData[key]);\n                        clusters.push({\n                            posX: tempPos.x,\n                            posY: tempPos.y,\n                            oldX: 0,\n                            oldY: 0,\n                            startPointsLen: groupedData[key].length,\n                            points: []\n                        });\n                    }\n                }\n                // Start kmeans iteration process.\n                while (repeat) {\n                    for (var _i = 0, clusters_1 = clusters; _i < clusters_1.length; _i++) {\n                        var c = clusters_1[_i];\n                        c.points.length = 0;\n                    }\n                    noise.length = 0;\n                    for (var i = 0; i < dataX.length; i++) {\n                        pointX = dataX[i];\n                        pointY = dataY[i];\n                        pointClusterDistance = series.getClusterDistancesFromPoint(clusters, pointX, pointY);\n                        if (pointClusterDistance.length &&\n                            pointClusterDistance[0].distance < pointMaxDistance) {\n                            clusters[pointClusterDistance[0].clusterIndex].points.push({\n                                x: pointX,\n                                y: pointY,\n                                dataIndex: dataIndexes[i]\n                            });\n                        }\n                        else {\n                            noise.push({\n                                x: pointX,\n                                y: pointY,\n                                dataIndex: dataIndexes[i]\n                            });\n                        }\n                    }\n                    // When cluster points array has only one point the\n                    // point should be classified again.\n                    for (var i = 0; i < clusters.length; i++) {\n                        if (clusters[i].points.length === 1) {\n                            pointClusterDistance = series.getClusterDistancesFromPoint(clusters, clusters[i].points[0].x, clusters[i].points[0].y);\n                            if (pointClusterDistance[1].distance < pointMaxDistance) {\n                                // Add point to the next closest cluster.\n                                clusters[pointClusterDistance[1].clusterIndex].points\n                                    .push(clusters[i].points[0]);\n                                // Clear points array.\n                                clusters[pointClusterDistance[0].clusterIndex]\n                                    .points.length = 0;\n                            }\n                        }\n                    }\n                    // Compute a new clusters position and check if it\n                    // is different than the old one.\n                    repeat = false;\n                    for (var i = 0; i < clusters.length; i++) {\n                        tempPos = getClusterPosition(clusters[i].points);\n                        clusters[i].oldX = clusters[i].posX;\n                        clusters[i].oldY = clusters[i].posY;\n                        clusters[i].posX = tempPos.x;\n                        clusters[i].posY = tempPos.y;\n                        // Repeat the algorithm if at least one cluster\n                        // is shifted more than maxClusterShift property.\n                        if (clusters[i].posX > clusters[i].oldX + maxClusterShift ||\n                            clusters[i].posX < clusters[i].oldX - maxClusterShift ||\n                            clusters[i].posY > clusters[i].oldY + maxClusterShift ||\n                            clusters[i].posY < clusters[i].oldY - maxClusterShift) {\n                            repeat = true;\n                        }\n                    }\n                    // If iterations property is set repeat the algorithm\n                    // specified amount of times.\n                    if (iterations) {\n                        repeat = currentIteration < iterations - 1;\n                    }\n                    currentIteration++;\n                }\n                for (var i = 0, iEnd = clusters.length; i < iEnd; ++i) {\n                    group['cluster' + i] = clusters[i].points;\n                }\n                for (var i = 0, iEnd = noise.length; i < iEnd; ++i) {\n                    group['noise' + i] = [noise[i]];\n                }\n                return group;\n            },\n            optimizedKmeans: function (processedXData, processedYData, dataIndexes, options) {\n                var series = this, pointMaxDistance = options.processedDistance ||\n                    clusterDefaults.layoutAlgorithm.gridSize, extremes = series.getRealExtremes(), clusterMarkerOptions = (series.options.cluster || {}).marker;\n                var distance, group = {}, offset, radius;\n                if (!series.markerClusterInfo || (series.initMaxX && series.initMaxX < extremes.maxX ||\n                    series.initMinX && series.initMinX > extremes.minX ||\n                    series.initMaxY && series.initMaxY < extremes.maxY ||\n                    series.initMinY && series.initMinY > extremes.minY)) {\n                    series.initMaxX = extremes.maxX;\n                    series.initMinX = extremes.minX;\n                    series.initMaxY = extremes.maxY;\n                    series.initMinY = extremes.minY;\n                    group = series.markerClusterAlgorithms ?\n                        series.markerClusterAlgorithms.kmeans.call(series, processedXData, processedYData, dataIndexes, options) : {};\n                    series.baseClusters = null;\n                }\n                else {\n                    if (!series.baseClusters) {\n                        series.baseClusters = {\n                            clusters: series.markerClusterInfo.clusters,\n                            noise: series.markerClusterInfo.noise\n                        };\n                    }\n                    for (var _i = 0, _a = series.baseClusters.clusters; _i < _a.length; _i++) {\n                        var cluster = _a[_i];\n                        cluster.pointsOutside = [];\n                        cluster.pointsInside = [];\n                        for (var _b = 0, _c = cluster.data; _b < _c.length; _b++) {\n                            var dataPoint = _c[_b];\n                            var dataPointPx = valuesToPixels(series, dataPoint), clusterPx = valuesToPixels(series, cluster);\n                            distance = Math.sqrt(Math.pow(dataPointPx.x - clusterPx.x, 2) +\n                                Math.pow(dataPointPx.y - clusterPx.y, 2));\n                            if (cluster.clusterZone &&\n                                cluster.clusterZone.marker &&\n                                cluster.clusterZone.marker.radius) {\n                                radius = cluster.clusterZone.marker.radius;\n                            }\n                            else if (clusterMarkerOptions &&\n                                clusterMarkerOptions.radius) {\n                                radius = clusterMarkerOptions.radius;\n                            }\n                            else {\n                                radius = clusterDefaults.marker.radius;\n                            }\n                            offset = pointMaxDistance - radius >= 0 ?\n                                pointMaxDistance - radius : radius;\n                            if (distance > radius + offset &&\n                                defined(cluster.pointsOutside)) {\n                                cluster.pointsOutside.push(dataPoint);\n                            }\n                            else if (defined(cluster.pointsInside)) {\n                                cluster.pointsInside.push(dataPoint);\n                            }\n                        }\n                        if (cluster.pointsInside.length) {\n                            group[cluster.id] = cluster.pointsInside;\n                        }\n                        var i = 0;\n                        for (var _d = 0, _e = cluster.pointsOutside; _d < _e.length; _d++) {\n                            var p = _e[_d];\n                            group[cluster.id + '_noise' + i++] = [p];\n                        }\n                    }\n                    for (var _f = 0, _g = series.baseClusters.noise; _f < _g.length; _f++) {\n                        var noise = _g[_f];\n                        group[noise.id] = noise.data;\n                    }\n                }\n                return group;\n            }\n        };\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        var baseGeneratePoints;\n        /**\n         * Points that ids are included in the oldPointsStateId array are hidden before\n         * animation. Other ones are destroyed.\n         * @private\n         */\n        var oldPointsStateId = [];\n        var stateIdCounter = 0;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /** @private */\n        function compose(highchartsDefaultOptions, ScatterSeriesClass) {\n            var scatterProto = ScatterSeriesClass.prototype;\n            if (!scatterProto.markerClusterAlgorithms) {\n                baseGeneratePoints = scatterProto.generatePoints;\n                scatterProto.markerClusterAlgorithms = markerClusterAlgorithms;\n                scatterProto.animateClusterPoint = seriesAnimateClusterPoint;\n                scatterProto.destroyClusteredData = seriesDestroyClusteredData;\n                scatterProto.generatePoints = seriesGeneratePoints;\n                scatterProto.getClusterDistancesFromPoint =\n                    seriesGetClusterDistancesFromPoint;\n                scatterProto.getClusteredData = seriesGetClusteredData;\n                scatterProto.getGridOffset = seriesGetGridOffset;\n                scatterProto.getPointsState = seriesGetPointsState;\n                scatterProto.getRealExtremes = seriesGetRealExtremes;\n                scatterProto.getScaledGridSize = seriesGetScaledGridSize;\n                scatterProto.hideClusteredData = seriesHideClusteredData;\n                scatterProto.isValidGroupedDataObject = seriesIsValidGroupedDataObject;\n                scatterProto.preventClusterCollisions = seriesPreventClusterCollisions;\n                // Destroy grouped data on series destroy.\n                addEvent(ScatterSeriesClass, 'destroy', scatterProto.destroyClusteredData);\n                (highchartsDefaultOptions.plotOptions || {}).series = merge((highchartsDefaultOptions.plotOptions || {}).series, MarkerClusterDefaults);\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function destroyOldPoints(oldState) {\n            if (oldState) {\n                var state = void 0;\n                for (var _i = 0, _a = Object.keys(oldState); _i < _a.length; _i++) {\n                    var key = _a[_i];\n                    state = oldState[key];\n                    if (state.point && state.point.destroy) {\n                        state.point.destroy();\n                    }\n                }\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function fadeInElement(elem, opacity, animation) {\n            elem\n                .attr({\n                opacity: opacity\n            })\n                .animate({\n                opacity: 1\n            }, animation);\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, opacity) {\n            // Fade in new point.\n            fadeInStatePoint(newPointObj, opacity, animation, true, true);\n            // Destroy old animated points.\n            for (var _i = 0, oldPoints_1 = oldPoints; _i < oldPoints_1.length; _i++) {\n                var p = oldPoints_1[_i];\n                if (p.point && p.point.destroy) {\n                    p.point.destroy();\n                }\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function fadeInStatePoint(stateObj, opacity, animation, fadeinGraphic, fadeinDataLabel) {\n            if (stateObj.point) {\n                if (fadeinGraphic && stateObj.point.graphic) {\n                    stateObj.point.graphic.show();\n                    fadeInElement(stateObj.point.graphic, opacity, animation);\n                }\n                if (fadeinDataLabel && stateObj.point.dataLabel) {\n                    stateObj.point.dataLabel.show();\n                    fadeInElement(stateObj.point.dataLabel, opacity, animation);\n                }\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function getClusterPosition(points) {\n            var pointsLen = points.length;\n            var sumX = 0, sumY = 0;\n            for (var i = 0; i < pointsLen; i++) {\n                sumX += points[i].x;\n                sumY += points[i].y;\n            }\n            return {\n                x: sumX / pointsLen,\n                y: sumY / pointsLen\n            };\n        }\n        /**\n         * Util function.Prepare array with sorted data objects to be compared in\n         * getPointsState method.\n         * @private\n         */\n        function getDataState(clusteredData, stateDataLen) {\n            var state = [];\n            state.length = stateDataLen;\n            clusteredData.clusters.forEach(function (cluster) {\n                cluster.data.forEach(function (elem) {\n                    state[elem.dataIndex] = elem;\n                });\n            });\n            clusteredData.noise.forEach(function (noise) {\n                state[noise.data[0].dataIndex] = noise.data[0];\n            });\n            return state;\n        }\n        /**\n         * Util function. Generate unique stateId for a state element.\n         * @private\n         */\n        function getStateId() {\n            return Math.random().toString(36).substring(2, 7) + '-' + stateIdCounter++;\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function hideStatePoint(stateObj, hideGraphic, hideDataLabel) {\n            if (stateObj.point) {\n                if (hideGraphic && stateObj.point.graphic) {\n                    stateObj.point.graphic.hide();\n                }\n                if (hideDataLabel && stateObj.point.dataLabel) {\n                    stateObj.point.dataLabel.hide();\n                }\n            }\n        }\n        /** @private */\n        function onPointDrillToCluster(event) {\n            var point = event.point || event.target;\n            point.firePointEvent('drillToCluster', event, function (e) {\n                var _a, _b, _c;\n                var point = e.point || e.target, series = point.series, xAxis = point.series.xAxis, yAxis = point.series.yAxis, chart = point.series.chart, inverted = chart.inverted, mapView = chart.mapView, pointer = chart.pointer, clusterOptions = series.options.cluster, drillToCluster = (clusterOptions || {}).drillToCluster;\n                if (drillToCluster && point.clusteredData) {\n                    var sortedDataX = point.clusteredData\n                        .map(function (data) { return data.x; })\n                        .sort(function (a, b) { return a - b; }), sortedDataY = point.clusteredData\n                        .map(function (data) { return data.y; })\n                        .sort(function (a, b) { return a - b; }), minX = sortedDataX[0], maxX = sortedDataX[sortedDataX.length - 1], minY = sortedDataY[0], maxY = sortedDataY[sortedDataY.length - 1], offsetX = Math.abs((maxX - minX) * 0.1), offsetY = Math.abs((maxY - minY) * 0.1), x1 = Math.min(minX, maxX) - offsetX, x2 = Math.max(minX, maxX) + offsetX, y1 = Math.min(minY, maxY) - offsetY, y2 = Math.max(minY, maxY) + offsetY;\n                    if (mapView) {\n                        mapView.fitToBounds({ x1: x1, x2: x2, y1: y1, y2: y2 });\n                    }\n                    else if (xAxis && yAxis) {\n                        var x1Px = xAxis.toPixels(x1), x2Px = xAxis.toPixels(x2), y1Px = yAxis.toPixels(y1), y2Px = yAxis.toPixels(y2);\n                        if (inverted) {\n                            _a = [y1Px, y2Px, x1Px, x2Px], x1Px = _a[0], x2Px = _a[1], y1Px = _a[2], y2Px = _a[3];\n                        }\n                        if (x1Px > x2Px) {\n                            _b = [x2Px, x1Px], x1Px = _b[0], x2Px = _b[1];\n                        }\n                        if (y1Px > y2Px) {\n                            _c = [y2Px, y1Px], y1Px = _c[0], y2Px = _c[1];\n                        }\n                        if (pointer) {\n                            pointer.zoomX = true;\n                            pointer.zoomY = true;\n                        }\n                        chart.transform({\n                            from: {\n                                x: x1Px,\n                                y: y1Px,\n                                width: x2Px - x1Px,\n                                height: y2Px - y1Px\n                            }\n                        });\n                    }\n                }\n            });\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function pixelsToValues(series, pos) {\n            var chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis;\n            if (chart.mapView) {\n                return chart.mapView.pixelsToProjectedUnits(pos);\n            }\n            return {\n                x: xAxis ? xAxis.toValue(pos.x) : 0,\n                y: yAxis ? yAxis.toValue(pos.y) : 0\n            };\n        }\n        /** @private */\n        function seriesAnimateClusterPoint(clusterObj) {\n            var series = this, chart = series.chart, mapView = chart.mapView, clusterOptions = series.options.cluster, animation = animObject((clusterOptions || {}).animation), animDuration = animation.duration || 500, pointsState = (series.markerClusterInfo || {}).pointsState, newState = (pointsState || {}).newState, oldState = (pointsState || {}).oldState, oldPoints = [];\n            var parentId, oldPointObj, newPointObj, newPointBBox, offset = 0, newX = 0, newY = 0, isOldPointGrahic = false, isCbHandled = false;\n            if (oldState && newState) {\n                newPointObj = newState[clusterObj.stateId];\n                var newPos = valuesToPixels(series, newPointObj);\n                newX = newPos.x - (mapView ? 0 : chart.plotLeft);\n                newY = newPos.y - (mapView ? 0 : chart.plotTop);\n                // Point has one ancestor.\n                if (newPointObj.parentsId.length === 1) {\n                    parentId = (newState || {})[clusterObj.stateId].parentsId[0];\n                    oldPointObj = oldState[parentId];\n                    // If old and new positions are the same do not animate.\n                    if (newPointObj.point &&\n                        newPointObj.point.graphic &&\n                        oldPointObj &&\n                        oldPointObj.point &&\n                        oldPointObj.point.plotX &&\n                        oldPointObj.point.plotY &&\n                        oldPointObj.point.plotX !== newPointObj.point.plotX &&\n                        oldPointObj.point.plotY !== newPointObj.point.plotY) {\n                        newPointBBox = newPointObj.point.graphic.getBBox();\n                        // Marker image does not have the offset (#14342).\n                        offset = (newPointObj.point.graphic &&\n                            newPointObj.point.graphic.isImg) ?\n                            0 : newPointBBox.width / 2;\n                        newPointObj.point.graphic.attr({\n                            x: oldPointObj.point.plotX - offset,\n                            y: oldPointObj.point.plotY - offset\n                        });\n                        newPointObj.point.graphic.animate({\n                            x: newX - (newPointObj.point.graphic.radius || 0),\n                            y: newY - (newPointObj.point.graphic.radius || 0)\n                        }, animation, function () {\n                            isCbHandled = true;\n                            // Destroy old point.\n                            if (oldPointObj.point && oldPointObj.point.destroy) {\n                                oldPointObj.point.destroy();\n                            }\n                        });\n                        // Data label animation.\n                        if (newPointObj.point.dataLabel &&\n                            newPointObj.point.dataLabel.alignAttr &&\n                            oldPointObj.point.dataLabel &&\n                            oldPointObj.point.dataLabel.alignAttr) {\n                            newPointObj.point.dataLabel.attr({\n                                x: oldPointObj.point.dataLabel.alignAttr.x,\n                                y: oldPointObj.point.dataLabel.alignAttr.y\n                            });\n                            newPointObj.point.dataLabel.animate({\n                                x: newPointObj.point.dataLabel.alignAttr.x,\n                                y: newPointObj.point.dataLabel.alignAttr.y\n                            }, animation);\n                        }\n                    }\n                }\n                else if (newPointObj.parentsId.length === 0) {\n                    // Point has no ancestors - new point.\n                    // Hide new point.\n                    hideStatePoint(newPointObj, true, true);\n                    syncTimeout(function () {\n                        // Fade in new point.\n                        fadeInStatePoint(newPointObj, 0.1, animation, true, true);\n                    }, animDuration / 2);\n                }\n                else {\n                    // Point has many ancestors.\n                    // Hide new point before animation.\n                    hideStatePoint(newPointObj, true, true);\n                    newPointObj.parentsId.forEach(function (elem) {\n                        if (oldState && oldState[elem]) {\n                            oldPointObj = oldState[elem];\n                            oldPoints.push(oldPointObj);\n                            if (oldPointObj.point &&\n                                oldPointObj.point.graphic) {\n                                isOldPointGrahic = true;\n                                oldPointObj.point.graphic.show();\n                                oldPointObj.point.graphic.animate({\n                                    x: newX - (oldPointObj.point.graphic.radius || 0),\n                                    y: newY - (oldPointObj.point.graphic.radius || 0),\n                                    opacity: 0.4\n                                }, animation, function () {\n                                    isCbHandled = true;\n                                    fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.7);\n                                });\n                                if (oldPointObj.point.dataLabel &&\n                                    oldPointObj.point.dataLabel.y !== -9999 &&\n                                    newPointObj.point &&\n                                    newPointObj.point.dataLabel &&\n                                    newPointObj.point.dataLabel.alignAttr) {\n                                    oldPointObj.point.dataLabel.show();\n                                    oldPointObj.point.dataLabel.animate({\n                                        x: newPointObj.point.dataLabel.alignAttr.x,\n                                        y: newPointObj.point.dataLabel.alignAttr.y,\n                                        opacity: 0.4\n                                    }, animation);\n                                }\n                            }\n                        }\n                    });\n                    // Make sure point is faded in.\n                    syncTimeout(function () {\n                        if (!isCbHandled) {\n                            fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.85);\n                        }\n                    }, animDuration);\n                    if (!isOldPointGrahic) {\n                        syncTimeout(function () {\n                            fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.1);\n                        }, animDuration / 2);\n                    }\n                }\n            }\n        }\n        /**\n         * Destroy clustered data points.\n         * @private\n         */\n        function seriesDestroyClusteredData() {\n            var clusteredSeriesData = this.markerClusterSeriesData;\n            // Clear previous groups.\n            (clusteredSeriesData || []).forEach(function (point) {\n                if (point && point.destroy) {\n                    point.destroy();\n                }\n            });\n            this.markerClusterSeriesData = null;\n        }\n        /**\n         * Override the generatePoints method by adding a reference to grouped data.\n         * @private\n         */\n        function seriesGeneratePoints() {\n            var series = this, chart = series.chart, mapView = chart.mapView, xData = series.xData, yData = series.yData, clusterOptions = series.options.cluster, realExtremes = series.getRealExtremes(), visibleXData = [], visibleYData = [], visibleDataIndexes = [];\n            var oldPointsState, oldDataLen, oldMarkerClusterInfo, kmeansThreshold, cropDataOffsetX, cropDataOffsetY, seriesMinX, seriesMaxX, seriesMinY, seriesMaxY, type, algorithm, clusteredData, groupedData, layoutAlgOptions, point, i;\n            // For map point series, we need to resolve lon, lat and geometry options\n            // and project them on the plane in order to get x and y. In the regular\n            // series flow, this is not done until the `translate` method because the\n            // resulting [x, y] position depends on inset positions in the MapView.\n            if (mapView && series.is('mappoint') && xData && yData) {\n                (series.options.data || []).forEach(function (p, i) {\n                    var xy = series.projectPoint(p);\n                    if (xy) {\n                        xData[i] = xy.x;\n                        yData[i] = xy.y;\n                    }\n                });\n            }\n            if (clusterOptions &&\n                clusterOptions.enabled &&\n                xData &&\n                xData.length &&\n                yData &&\n                yData.length &&\n                !chart.polar) {\n                type = clusterOptions.layoutAlgorithm.type;\n                layoutAlgOptions = clusterOptions.layoutAlgorithm;\n                // Get processed algorithm properties.\n                layoutAlgOptions.processedGridSize = relativeLength(layoutAlgOptions.gridSize ||\n                    clusterDefaults.layoutAlgorithm.gridSize, chart.plotWidth);\n                layoutAlgOptions.processedDistance = relativeLength(layoutAlgOptions.distance ||\n                    clusterDefaults.layoutAlgorithm.distance, chart.plotWidth);\n                kmeansThreshold = layoutAlgOptions.kmeansThreshold ||\n                    clusterDefaults.layoutAlgorithm.kmeansThreshold;\n                // Offset to prevent cluster size changes.\n                var halfGrid = layoutAlgOptions.processedGridSize / 2, p1 = pixelsToValues(series, { x: 0, y: 0 }), p2 = pixelsToValues(series, { x: halfGrid, y: halfGrid });\n                cropDataOffsetX = Math.abs(p1.x - p2.x);\n                cropDataOffsetY = Math.abs(p1.y - p2.y);\n                // Get only visible data.\n                for (i = 0; i < xData.length; i++) {\n                    if (!series.dataMaxX) {\n                        if (!defined(seriesMaxX) ||\n                            !defined(seriesMinX) ||\n                            !defined(seriesMaxY) ||\n                            !defined(seriesMinY)) {\n                            seriesMaxX = seriesMinX = xData[i];\n                            seriesMaxY = seriesMinY = yData[i];\n                        }\n                        else if (isNumber(yData[i]) &&\n                            isNumber(seriesMaxY) &&\n                            isNumber(seriesMinY)) {\n                            seriesMaxX = Math.max(xData[i], seriesMaxX);\n                            seriesMinX = Math.min(xData[i], seriesMinX);\n                            seriesMaxY = Math.max(yData[i] || seriesMaxY, seriesMaxY);\n                            seriesMinY = Math.min(yData[i] || seriesMinY, seriesMinY);\n                        }\n                    }\n                    // Crop data to visible ones with appropriate offset to prevent\n                    // cluster size changes on the edge of the plot area.\n                    if (xData[i] >= (realExtremes.minX - cropDataOffsetX) &&\n                        xData[i] <= (realExtremes.maxX + cropDataOffsetX) &&\n                        (yData[i] || realExtremes.minY) >=\n                            (realExtremes.minY - cropDataOffsetY) &&\n                        (yData[i] || realExtremes.maxY) <=\n                            (realExtremes.maxY + cropDataOffsetY)) {\n                        visibleXData.push(xData[i]);\n                        visibleYData.push(yData[i]);\n                        visibleDataIndexes.push(i);\n                    }\n                }\n                // Save data max values.\n                if (defined(seriesMaxX) && defined(seriesMinX) &&\n                    isNumber(seriesMaxY) && isNumber(seriesMinY)) {\n                    series.dataMaxX = seriesMaxX;\n                    series.dataMinX = seriesMinX;\n                    series.dataMaxY = seriesMaxY;\n                    series.dataMinY = seriesMinY;\n                }\n                if (isFunction(type)) {\n                    algorithm = type;\n                }\n                else if (series.markerClusterAlgorithms) {\n                    if (type && series.markerClusterAlgorithms[type]) {\n                        algorithm = series.markerClusterAlgorithms[type];\n                    }\n                    else {\n                        algorithm = visibleXData.length < kmeansThreshold ?\n                            series.markerClusterAlgorithms.kmeans :\n                            series.markerClusterAlgorithms.grid;\n                    }\n                }\n                else {\n                    algorithm = function () {\n                        return false;\n                    };\n                }\n                groupedData = algorithm.call(this, visibleXData, visibleYData, visibleDataIndexes, layoutAlgOptions);\n                clusteredData = groupedData ? series.getClusteredData(groupedData, clusterOptions) : groupedData;\n                // When animation is enabled get old points state.\n                if (clusterOptions.animation &&\n                    series.markerClusterInfo &&\n                    series.markerClusterInfo.pointsState &&\n                    series.markerClusterInfo.pointsState.oldState) {\n                    // Destroy old points.\n                    destroyOldPoints(series.markerClusterInfo.pointsState.oldState);\n                    oldPointsState = series.markerClusterInfo.pointsState.newState;\n                }\n                else {\n                    oldPointsState = {};\n                }\n                // Save points old state info.\n                oldDataLen = xData.length;\n                oldMarkerClusterInfo = series.markerClusterInfo;\n                if (clusteredData) {\n                    series.processedXData = clusteredData.groupedXData;\n                    series.processedYData = clusteredData.groupedYData;\n                    series.hasGroupedData = true;\n                    series.markerClusterInfo = clusteredData;\n                    series.groupMap = clusteredData.groupMap;\n                }\n                baseGeneratePoints.apply(this);\n                if (clusteredData && series.markerClusterInfo) {\n                    // Mark cluster points. Safe point reference in the cluster object.\n                    (series.markerClusterInfo.clusters || []).forEach(function (cluster) {\n                        point = series.points[cluster.index];\n                        point.isCluster = true;\n                        point.clusteredData = cluster.data;\n                        point.clusterPointsAmount = cluster.data.length;\n                        cluster.point = point;\n                        // Add zoom to cluster range.\n                        addEvent(point, 'click', onPointDrillToCluster);\n                    });\n                    // Safe point reference in the noise object.\n                    (series.markerClusterInfo.noise || []).forEach(function (noise) {\n                        noise.point = series.points[noise.index];\n                    });\n                    // When animation is enabled save points state.\n                    if (clusterOptions.animation &&\n                        series.markerClusterInfo) {\n                        series.markerClusterInfo.pointsState = {\n                            oldState: oldPointsState,\n                            newState: series.getPointsState(clusteredData, oldMarkerClusterInfo, oldDataLen)\n                        };\n                    }\n                    // Record grouped data in order to let it be destroyed the next time\n                    // processData runs.\n                    if (!clusterOptions.animation) {\n                        this.destroyClusteredData();\n                    }\n                    else {\n                        this.hideClusteredData();\n                    }\n                    this.markerClusterSeriesData =\n                        this.hasGroupedData ? this.points : null;\n                }\n            }\n            else {\n                baseGeneratePoints.apply(this);\n            }\n        }\n        /** @private */\n        function seriesGetClusterDistancesFromPoint(clusters, pointX, pointY) {\n            var pointClusterDistance = [];\n            for (var clusterIndex = 0; clusterIndex < clusters.length; clusterIndex++) {\n                var p1 = valuesToPixels(this, { x: pointX, y: pointY }), p2 = valuesToPixels(this, {\n                    x: clusters[clusterIndex].posX,\n                    y: clusters[clusterIndex].posY\n                }), distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) +\n                    Math.pow(p1.y - p2.y, 2));\n                pointClusterDistance.push({ clusterIndex: clusterIndex, distance: distance });\n            }\n            return pointClusterDistance.sort(function (a, b) { return a.distance - b.distance; });\n        }\n        /** @private */\n        function seriesGetClusteredData(groupedData, options) {\n            var series = this, groupedXData = [], groupedYData = [], clusters = [], // Container for clusters.\n            noise = [], // Container for points not belonging to any cluster.\n            groupMap = [], \n            // Prevent minimumClusterSize lower than 2.\n            minimumClusterSize = Math.max(2, options.minimumClusterSize || 2);\n            var index = 0, stateId, point, points, pointUserOptions, pointsLen, marker, clusterPos, pointOptions, clusterTempPos, zoneOptions, clusterZone, clusterZoneClassName, i, k;\n            // Check if groupedData is valid when user uses a custom algorithm.\n            if (isFunction(options.layoutAlgorithm.type) &&\n                !series.isValidGroupedDataObject(groupedData)) {\n                error('Highcharts marker-clusters module: ' +\n                    'The custom algorithm result is not valid!', false, series.chart);\n                return false;\n            }\n            for (k in groupedData) {\n                if (groupedData[k].length >= minimumClusterSize) {\n                    points = groupedData[k];\n                    stateId = getStateId();\n                    pointsLen = points.length;\n                    // Get zone options for cluster.\n                    if (options.zones) {\n                        for (i = 0; i < options.zones.length; i++) {\n                            if (pointsLen >= options.zones[i].from &&\n                                pointsLen <= options.zones[i].to) {\n                                clusterZone = options.zones[i];\n                                clusterZone.zoneIndex = i;\n                                zoneOptions = options.zones[i].marker;\n                                clusterZoneClassName = options.zones[i].className;\n                            }\n                        }\n                    }\n                    clusterTempPos = getClusterPosition(points);\n                    if (options.layoutAlgorithm.type === 'grid' &&\n                        !options.allowOverlap) {\n                        marker = series.options.marker || {};\n                        clusterPos = series.preventClusterCollisions({\n                            x: clusterTempPos.x,\n                            y: clusterTempPos.y,\n                            key: k,\n                            groupedData: groupedData,\n                            gridSize: series.getScaledGridSize(options.layoutAlgorithm),\n                            defaultRadius: marker.radius || 3 + (marker.lineWidth || 0),\n                            clusterRadius: (zoneOptions && zoneOptions.radius) ?\n                                zoneOptions.radius :\n                                (options.marker || {}).radius ||\n                                    clusterDefaults.marker.radius\n                        });\n                    }\n                    else {\n                        clusterPos = {\n                            x: clusterTempPos.x,\n                            y: clusterTempPos.y\n                        };\n                    }\n                    for (i = 0; i < pointsLen; i++) {\n                        points[i].parentStateId = stateId;\n                    }\n                    clusters.push({\n                        x: clusterPos.x,\n                        y: clusterPos.y,\n                        id: k,\n                        stateId: stateId,\n                        index: index,\n                        data: points,\n                        clusterZone: clusterZone,\n                        clusterZoneClassName: clusterZoneClassName\n                    });\n                    groupedXData.push(clusterPos.x);\n                    groupedYData.push(clusterPos.y);\n                    groupMap.push({\n                        options: {\n                            formatPrefix: 'cluster',\n                            dataLabels: options.dataLabels,\n                            marker: merge(options.marker, {\n                                states: options.states\n                            }, zoneOptions || {})\n                        }\n                    });\n                    // Save cluster data points options.\n                    if (series.options.data && series.options.data.length) {\n                        for (i = 0; i < pointsLen; i++) {\n                            if (isObject(series.options.data[points[i].dataIndex])) {\n                                points[i].options =\n                                    series.options.data[points[i].dataIndex];\n                            }\n                        }\n                    }\n                    index++;\n                    zoneOptions = null;\n                }\n                else {\n                    for (i = 0; i < groupedData[k].length; i++) {\n                        // Points not belonging to any cluster.\n                        point = groupedData[k][i];\n                        stateId = getStateId();\n                        pointOptions = null;\n                        pointUserOptions =\n                            ((series.options || {}).data || [])[point.dataIndex];\n                        groupedXData.push(point.x);\n                        groupedYData.push(point.y);\n                        point.parentStateId = stateId;\n                        noise.push({\n                            x: point.x,\n                            y: point.y,\n                            id: k,\n                            stateId: stateId,\n                            index: index,\n                            data: groupedData[k]\n                        });\n                        if (pointUserOptions &&\n                            typeof pointUserOptions === 'object' &&\n                            !isArray(pointUserOptions)) {\n                            pointOptions = merge(pointUserOptions, { x: point.x, y: point.y });\n                        }\n                        else {\n                            pointOptions = {\n                                userOptions: pointUserOptions,\n                                x: point.x,\n                                y: point.y\n                            };\n                        }\n                        groupMap.push({ options: pointOptions });\n                        index++;\n                    }\n                }\n            }\n            return {\n                clusters: clusters,\n                noise: noise,\n                groupedXData: groupedXData,\n                groupedYData: groupedYData,\n                groupMap: groupMap\n            };\n        }\n        /** @private */\n        function seriesGetGridOffset() {\n            var series = this, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis;\n            var plotLeft = 0, plotTop = 0;\n            if (xAxis && series.dataMinX && series.dataMaxX) {\n                plotLeft = xAxis.reversed ?\n                    xAxis.toPixels(series.dataMaxX) : xAxis.toPixels(series.dataMinX);\n            }\n            else {\n                plotLeft = chart.plotLeft;\n            }\n            if (yAxis && series.dataMinY && series.dataMaxY) {\n                plotTop = yAxis.reversed ?\n                    yAxis.toPixels(series.dataMinY) : yAxis.toPixels(series.dataMaxY);\n            }\n            else {\n                plotTop = chart.plotTop;\n            }\n            return { plotLeft: plotLeft, plotTop: plotTop };\n        }\n        /**\n         * Point state used when animation is enabled to compare and bind old points\n         * with new ones.\n         * @private\n         */\n        function seriesGetPointsState(clusteredData, oldMarkerClusterInfo, dataLength) {\n            var oldDataStateArr = oldMarkerClusterInfo ?\n                getDataState(oldMarkerClusterInfo, dataLength) : [], newDataStateArr = getDataState(clusteredData, dataLength), state = {};\n            // Clear global array before populate with new ids.\n            oldPointsStateId = [];\n            // Build points state structure.\n            clusteredData.clusters.forEach(function (cluster) {\n                state[cluster.stateId] = {\n                    x: cluster.x,\n                    y: cluster.y,\n                    id: cluster.stateId,\n                    point: cluster.point,\n                    parentsId: []\n                };\n            });\n            clusteredData.noise.forEach(function (noise) {\n                state[noise.stateId] = {\n                    x: noise.x,\n                    y: noise.y,\n                    id: noise.stateId,\n                    point: noise.point,\n                    parentsId: []\n                };\n            });\n            var newState, oldState;\n            // Bind new and old state.\n            for (var i = 0; i < newDataStateArr.length; i++) {\n                newState = newDataStateArr[i];\n                oldState = oldDataStateArr[i];\n                if (newState &&\n                    oldState &&\n                    newState.parentStateId &&\n                    oldState.parentStateId &&\n                    state[newState.parentStateId] &&\n                    state[newState.parentStateId].parentsId.indexOf(oldState.parentStateId) === -1) {\n                    state[newState.parentStateId].parentsId.push(oldState.parentStateId);\n                    if (oldPointsStateId.indexOf(oldState.parentStateId) === -1) {\n                        oldPointsStateId.push(oldState.parentStateId);\n                    }\n                }\n            }\n            return state;\n        }\n        /** @private */\n        function seriesGetRealExtremes() {\n            var chart = this.chart, x = chart.mapView ? 0 : chart.plotLeft, y = chart.mapView ? 0 : chart.plotTop, p1 = pixelsToValues(this, {\n                x: x,\n                y: y\n            }), p2 = pixelsToValues(this, {\n                x: x + chart.plotWidth,\n                y: x + chart.plotHeight\n            }), realMinX = p1.x, realMaxX = p2.x, realMinY = p1.y, realMaxY = p2.y;\n            return {\n                minX: Math.min(realMinX, realMaxX),\n                maxX: Math.max(realMinX, realMaxX),\n                minY: Math.min(realMinY, realMaxY),\n                maxY: Math.max(realMinY, realMaxY)\n            };\n        }\n        /** @private */\n        function seriesGetScaledGridSize(options) {\n            var series = this, xAxis = series.xAxis, mapView = this.chart.mapView, processedGridSize = options.processedGridSize ||\n                clusterDefaults.layoutAlgorithm.gridSize;\n            var search = true, k = 1, divider = 1;\n            if (!series.gridValueSize) {\n                if (mapView) {\n                    series.gridValueSize = processedGridSize / mapView.getScale();\n                }\n                else {\n                    series.gridValueSize = Math.abs(xAxis.toValue(processedGridSize) - xAxis.toValue(0));\n                }\n            }\n            var gridSize = mapView ?\n                series.gridValueSize * mapView.getScale() :\n                xAxis.toPixels(series.gridValueSize) - xAxis.toPixels(0);\n            var scale = +(processedGridSize / gridSize).toFixed(14);\n            // Find the level and its divider.\n            while (search && scale !== 1) {\n                var level = Math.pow(2, k);\n                if (scale > 0.75 && scale < 1.25) {\n                    search = false;\n                }\n                else if (scale >= (1 / level) && scale < 2 * (1 / level)) {\n                    search = false;\n                    divider = level;\n                }\n                else if (scale <= level && scale > level / 2) {\n                    search = false;\n                    divider = 1 / level;\n                }\n                k++;\n            }\n            return (processedGridSize / divider) / scale;\n        }\n        /**\n         * Hide clustered data points.\n         * @private\n         */\n        function seriesHideClusteredData() {\n            var series = this, clusteredSeriesData = this.markerClusterSeriesData, oldState = ((series.markerClusterInfo || {}).pointsState || {}).oldState || {}, oldPointsId = oldPointsStateId.map(function (elem) {\n                return (oldState[elem].point || {}).id || '';\n            });\n            (clusteredSeriesData || []).forEach(function (point) {\n                // If an old point is used in animation hide it, otherwise destroy.\n                if (point &&\n                    oldPointsId.indexOf(point.id) !== -1) {\n                    if (point.graphic) {\n                        point.graphic.hide();\n                    }\n                    if (point.dataLabel) {\n                        point.dataLabel.hide();\n                    }\n                }\n                else {\n                    if (point && point.destroy) {\n                        point.destroy();\n                    }\n                }\n            });\n        }\n        /**\n         * Check if user algorithm result is valid groupedDataObject.\n         * @private\n         */\n        function seriesIsValidGroupedDataObject(groupedData) {\n            var result = false, i;\n            if (!isObject(groupedData)) {\n                return false;\n            }\n            objectEach(groupedData, function (elem) {\n                result = true;\n                if (!isArray(elem) || !elem.length) {\n                    result = false;\n                    return;\n                }\n                for (i = 0; i < elem.length; i++) {\n                    if (!isObject(elem[i]) || (!elem[i].x || !elem[i].y)) {\n                        result = false;\n                        return;\n                    }\n                }\n            });\n            return result;\n        }\n        /** @private */\n        function seriesPreventClusterCollisions(props) {\n            var _a;\n            var series = this, _b = props.key.split('-').map(parseFloat), gridY = _b[0], gridX = _b[1], gridSize = props.gridSize, groupedData = props.groupedData, defaultRadius = props.defaultRadius, clusterRadius = props.clusterRadius, gridXPx = gridX * gridSize, gridYPx = gridY * gridSize, propsPx = valuesToPixels(series, props), gridsToCheckCollision = [], clusterMarkerOptions = (series.options.cluster || {}).marker, zoneOptions = (series.options.cluster || {}).zones, gridOffset = series.getGridOffset();\n            var xPixel = propsPx.x, yPixel = propsPx.y, pointsLen = 0, radius = 0, nextXPixel, nextYPixel, signX, signY, cornerGridX, cornerGridY, i, j, itemX, itemY, nextClusterPos, maxDist, keys;\n            // Distance to the grid start.\n            xPixel -= gridOffset.plotLeft;\n            yPixel -= gridOffset.plotTop;\n            for (i = 1; i < 5; i++) {\n                signX = i % 2 ? -1 : 1;\n                signY = i < 3 ? -1 : 1;\n                cornerGridX = Math.floor((xPixel + signX * clusterRadius) / gridSize);\n                cornerGridY = Math.floor((yPixel + signY * clusterRadius) / gridSize);\n                keys = [\n                    cornerGridY + '-' + cornerGridX,\n                    cornerGridY + '-' + gridX,\n                    gridY + '-' + cornerGridX\n                ];\n                for (j = 0; j < keys.length; j++) {\n                    if (gridsToCheckCollision.indexOf(keys[j]) === -1 &&\n                        keys[j] !== props.key) {\n                        gridsToCheckCollision.push(keys[j]);\n                    }\n                }\n            }\n            for (var _i = 0, gridsToCheckCollision_1 = gridsToCheckCollision; _i < gridsToCheckCollision_1.length; _i++) {\n                var item = gridsToCheckCollision_1[_i];\n                if (groupedData[item]) {\n                    // Cluster or noise position is already computed.\n                    if (!groupedData[item].posX) {\n                        nextClusterPos = getClusterPosition(groupedData[item]);\n                        groupedData[item].posX = nextClusterPos.x;\n                        groupedData[item].posY = nextClusterPos.y;\n                    }\n                    var pos_1 = valuesToPixels(series, {\n                        x: groupedData[item].posX || 0,\n                        y: groupedData[item].posY || 0\n                    });\n                    nextXPixel = pos_1.x - gridOffset.plotLeft;\n                    nextYPixel = pos_1.y - gridOffset.plotTop;\n                    _a = item.split('-').map(parseFloat), itemY = _a[0], itemX = _a[1];\n                    if (zoneOptions) {\n                        pointsLen = groupedData[item].length;\n                        for (i = 0; i < zoneOptions.length; i++) {\n                            if (pointsLen >= zoneOptions[i].from &&\n                                pointsLen <= zoneOptions[i].to) {\n                                if (defined((zoneOptions[i].marker || {}).radius)) {\n                                    radius = zoneOptions[i].marker.radius || 0;\n                                }\n                                else if (clusterMarkerOptions &&\n                                    clusterMarkerOptions.radius) {\n                                    radius = clusterMarkerOptions.radius;\n                                }\n                                else {\n                                    radius =\n                                        clusterDefaults.marker.radius;\n                                }\n                            }\n                        }\n                    }\n                    if (groupedData[item].length > 1 &&\n                        radius === 0 &&\n                        clusterMarkerOptions &&\n                        clusterMarkerOptions.radius) {\n                        radius = clusterMarkerOptions.radius;\n                    }\n                    else if (groupedData[item].length === 1) {\n                        radius = defaultRadius;\n                    }\n                    maxDist = clusterRadius + radius;\n                    radius = 0;\n                    if (itemX !== gridX &&\n                        Math.abs(xPixel - nextXPixel) < maxDist) {\n                        xPixel = itemX - gridX < 0 ? gridXPx + clusterRadius :\n                            gridXPx + gridSize - clusterRadius;\n                    }\n                    if (itemY !== gridY &&\n                        Math.abs(yPixel - nextYPixel) < maxDist) {\n                        yPixel = itemY - gridY < 0 ? gridYPx + clusterRadius :\n                            gridYPx + gridSize - clusterRadius;\n                    }\n                }\n            }\n            var pos = pixelsToValues(series, {\n                x: xPixel + gridOffset.plotLeft,\n                y: yPixel + gridOffset.plotTop\n            });\n            groupedData[props.key].posX = pos.x;\n            groupedData[props.key].posY = pos.y;\n            return pos;\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function valuesToPixels(series, pos) {\n            var chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis;\n            if (chart.mapView) {\n                return chart.mapView.projectedUnitsToPixels(pos);\n            }\n            return {\n                x: xAxis ? xAxis.toPixels(pos.x) : 0,\n                y: yAxis ? yAxis.toPixels(pos.y) : 0\n            };\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var MarkerClusterScatter = {\n            compose: compose\n        };\n\n        return MarkerClusterScatter;\n    });\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusters.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Extensions/MarkerClusters/MarkerClusterDefaults.js'], _modules['Extensions/MarkerClusters/MarkerClusterScatter.js'], _modules['Core/Utilities.js']], function (A, D, H, MarkerClusterDefaults, MarkerClusterScatter, U) {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var animObject = A.animObject;\n        var defaultOptions = D.defaultOptions;\n        var composed = H.composed;\n        var addEvent = U.addEvent, defined = U.defined, error = U.error, isFunction = U.isFunction, merge = U.merge, pushUnique = U.pushUnique, syncTimeout = U.syncTimeout;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        (defaultOptions.plotOptions || {}).series = merge((defaultOptions.plotOptions || {}).series, MarkerClusterDefaults);\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /** @private */\n        function compose(AxisClass, ChartClass, highchartsDefaultOptions, SeriesClass) {\n            if (pushUnique(composed, 'MarkerClusters')) {\n                var PointClass = SeriesClass.prototype.pointClass, ScatterSeries = SeriesClass.types.scatter;\n                addEvent(AxisClass, 'setExtremes', onAxisSetExtremes);\n                addEvent(ChartClass, 'render', onChartRender);\n                addEvent(PointClass, 'drillToCluster', onPointDrillToCluster);\n                addEvent(PointClass, 'update', onPointUpdate);\n                addEvent(SeriesClass, 'afterRender', onSeriesAfterRender);\n                if (ScatterSeries) {\n                    MarkerClusterScatter\n                        .compose(highchartsDefaultOptions, ScatterSeries);\n                }\n            }\n        }\n        /**\n         * Destroy the old tooltip after zoom.\n         * @private\n         */\n        function onAxisSetExtremes() {\n            var chart = this.chart;\n            var animationDuration = 0;\n            for (var _i = 0, _a = chart.series; _i < _a.length; _i++) {\n                var series = _a[_i];\n                if (series.markerClusterInfo) {\n                    animationDuration = (animObject((series.options.cluster || {}).animation).duration ||\n                        0);\n                }\n            }\n            syncTimeout(function () {\n                if (chart.tooltip) {\n                    chart.tooltip.destroy();\n                }\n            }, animationDuration);\n        }\n        /**\n         * Handle animation.\n         * @private\n         */\n        function onChartRender() {\n            var _a;\n            var chart = this;\n            for (var _i = 0, _b = (chart.series || []); _i < _b.length; _i++) {\n                var series = _b[_i];\n                if (series.markerClusterInfo) {\n                    var options = series.options.cluster, pointsState = (series.markerClusterInfo || {}).pointsState, oldState = (pointsState || {}).oldState;\n                    if ((options || {}).animation &&\n                        series.markerClusterInfo &&\n                        (((_a = series.chart.pointer) === null || _a === void 0 ? void 0 : _a.pinchDown) || []).length === 0 &&\n                        ((series.xAxis || {}).eventArgs || {}).trigger !== 'pan' &&\n                        oldState &&\n                        Object.keys(oldState).length) {\n                        for (var _c = 0, _d = series.markerClusterInfo.clusters; _c < _d.length; _c++) {\n                            var cluster = _d[_c];\n                            series.animateClusterPoint(cluster);\n                        }\n                        for (var _e = 0, _f = series.markerClusterInfo.noise; _e < _f.length; _e++) {\n                            var noise = _f[_e];\n                            series.animateClusterPoint(noise);\n                        }\n                    }\n                }\n            }\n        }\n        /** @private */\n        function onPointDrillToCluster(event) {\n            var point = event.point || event.target, series = point.series, clusterOptions = series.options.cluster, onDrillToCluster = ((clusterOptions || {}).events || {}).drillToCluster;\n            if (isFunction(onDrillToCluster)) {\n                onDrillToCluster.call(this, event);\n            }\n        }\n        /**\n         * Override point prototype to throw a warning when trying to update\n         * clustered point.\n         * @private\n         */\n        function onPointUpdate() {\n            var point = this;\n            if (point.dataGroup) {\n                error('Highcharts marker-clusters module: ' +\n                    'Running `Point.update` when point belongs to clustered series' +\n                    ' is not supported.', false, point.series.chart);\n                return false;\n            }\n        }\n        /**\n         * Add classes, change mouse cursor.\n         * @private\n         */\n        function onSeriesAfterRender() {\n            var series = this, clusterZoomEnabled = (series.options.cluster || {}).drillToCluster;\n            if (series.markerClusterInfo && series.markerClusterInfo.clusters) {\n                for (var _i = 0, _a = series.markerClusterInfo.clusters; _i < _a.length; _i++) {\n                    var cluster = _a[_i];\n                    if (cluster.point && cluster.point.graphic) {\n                        cluster.point.graphic.addClass('highcharts-cluster-point');\n                        // Change cursor to pointer when drillToCluster is enabled.\n                        if (clusterZoomEnabled && cluster.point) {\n                            cluster.point.graphic.css({\n                                cursor: 'pointer'\n                            });\n                            if (cluster.point.dataLabel) {\n                                cluster.point.dataLabel.css({\n                                    cursor: 'pointer'\n                                });\n                            }\n                        }\n                        if (defined(cluster.clusterZone)) {\n                            cluster.point.graphic.addClass(cluster.clusterZoneClassName ||\n                                'highcharts-cluster-zone-' +\n                                    cluster.clusterZone.zoneIndex);\n                        }\n                    }\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var MarkerClusters = {\n            compose: compose\n        };\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Function callback when a cluster is clicked.\n         *\n         * @callback Highcharts.MarkerClusterDrillCallbackFunction\n         *\n         * @param {Highcharts.Point} this\n         *        The point where the event occurred.\n         *\n         * @param {Highcharts.PointClickEventObject} event\n         *        Event arguments.\n         */\n        ''; // Keeps doclets above in JS file\n\n        return MarkerClusters;\n    });\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusterSymbols.js', [], function () {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        var symbols;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Cluster symbol.\n         * @private\n         */\n        function cluster(x, y, width, height) {\n            var w = width / 2, h = height / 2, outerWidth = 1, space = 1, inner = symbols.arc(x + w, y + h, w - space * 4, h - space * 4, {\n                start: Math.PI * 0.5,\n                end: Math.PI * 2.5,\n                open: false\n            }), outer1 = symbols.arc(x + w, y + h, w - space * 3, h - space * 3, {\n                start: Math.PI * 0.5,\n                end: Math.PI * 2.5,\n                innerR: w - outerWidth * 2,\n                open: false\n            }), outer2 = symbols.arc(x + w, y + h, w - space, h - space, {\n                start: Math.PI * 0.5,\n                end: Math.PI * 2.5,\n                innerR: w,\n                open: false\n            });\n            return outer2.concat(outer1, inner);\n        }\n        /**\n         * @private\n         */\n        function compose(SVGRendererClass) {\n            symbols = SVGRendererClass.prototype.symbols;\n            symbols.cluster = cluster;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var MarkerClusterSymbols = {\n            compose: compose\n        };\n\n        return MarkerClusterSymbols;\n    });\n    _registerModule(_modules, 'masters/modules/marker-clusters.src.js', [_modules['Core/Globals.js'], _modules['Extensions/MarkerClusters/MarkerClusters.js'], _modules['Extensions/MarkerClusters/MarkerClusterSymbols.js']], function (Highcharts, MarkerClusters, MarkerClusterSymbols) {\n\n        var G = Highcharts;\n        MarkerClusters.compose(G.Axis, G.Chart, G.defaultOptions, G.Series);\n        MarkerClusterSymbols.compose(G.SVGRenderer);\n\n        return Highcharts;\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","cluster","enabled","allowOverlap","animation","duration","drillToCluster","minimumClusterSize","layoutAlgorithm","gridSize","distance","kmeansThreshold","marker","symbol","radius","lineWidth","lineColor","dataLabels","format","verticalAlign","align","style","color","inside","tooltip","clusterFormat","A","MarkerClusterDefaults","U","baseGeneratePoints","animObject","clusterDefaults","addEvent","defined","error","isArray","isFunction","isObject","isNumber","merge","objectEach","relativeLength","syncTimeout","markerClusterAlgorithms","grid","dataX","dataY","dataIndexes","options","x","y","gridX","key","i","gridOffset","getGridOffset","scaledGridSize","series","getScaledGridSize","length","p","valuesToPixels","plotLeft","plotTop","Math","floor","gridY","push","dataIndex","kmeans","tempPos","clusters","noise","group","pointMaxDistance","processedDistance","iterations","currentIteration","repeat","pointX","pointY","pointClusterDistance","processedGridSize","groupedData","call","getClusterPosition","posX","posY","oldX","oldY","startPointsLen","points","_i","clusters_1","c","getClusterDistancesFromPoint","clusterIndex","iEnd","optimizedKmeans","processedXData","processedYData","offset","extremes","getRealExtremes","clusterMarkerOptions","markerClusterInfo","initMaxX","maxX","initMinX","minX","initMaxY","maxY","initMinY","minY","baseClusters","_a","pointsOutside","pointsInside","_b","_c","data","dataPoint","dataPointPx","clusterPx","sqrt","pow","clusterZone","id","_d","_e","_f","_g","oldPointsStateId","stateIdCounter","fadeInElement","elem","opacity","attr","animate","fadeInNewPointAndDestoryOld","newPointObj","oldPoints","fadeInStatePoint","oldPoints_1","point","destroy","stateObj","fadeinGraphic","fadeinDataLabel","graphic","show","dataLabel","pointsLen","sumX","sumY","getDataState","clusteredData","stateDataLen","state","forEach","getStateId","random","toString","substring","hideStatePoint","hideGraphic","hideDataLabel","hide","onPointDrillToCluster","event","target","firePointEvent","e","xAxis","yAxis","chart","inverted","mapView","pointer","clusterOptions","sortedDataX","map","sort","a","b","sortedDataY","offsetX","abs","offsetY","x1","min","x2","max","y1","y2","fitToBounds","x1Px","toPixels","x2Px","y1Px","y2Px","zoomX","zoomY","transform","from","width","height","pixelsToValues","pos","pixelsToProjectedUnits","toValue","seriesAnimateClusterPoint","clusterObj","oldPointObj","newPointBBox","animDuration","pointsState","newState","oldState","newX","newY","isOldPointGrahic","isCbHandled","newPos","stateId","parentsId","plotX","plotY","getBBox","isImg","alignAttr","seriesDestroyClusteredData","clusteredSeriesData","markerClusterSeriesData","seriesGeneratePoints","oldPointsState","oldDataLen","oldMarkerClusterInfo","cropDataOffsetX","cropDataOffsetY","seriesMinX","seriesMaxX","seriesMinY","seriesMaxY","type","layoutAlgOptions","xData","yData","realExtremes","visibleXData","visibleYData","visibleDataIndexes","is","xy","projectPoint","polar","plotWidth","halfGrid","p1","p2","dataMaxX","dataMinX","dataMaxY","dataMinY","algorithm","getClusteredData","destroyOldPoints","Object","keys","groupedXData","groupedYData","hasGroupedData","groupMap","index","isCluster","clusterPointsAmount","getPointsState","hideClusteredData","destroyClusteredData","seriesGetClusterDistancesFromPoint","seriesGetClusteredData","pointUserOptions","clusterPos","pointOptions","clusterTempPos","zoneOptions","clusterZoneClassName","k","isValidGroupedDataObject","zones","to","zoneIndex","className","preventClusterCollisions","defaultRadius","clusterRadius","parentStateId","formatPrefix","states","userOptions","seriesGetGridOffset","reversed","seriesGetPointsState","dataLength","oldDataStateArr","newDataStateArr","indexOf","seriesGetRealExtremes","plotHeight","realMinX","realMaxX","realMinY","realMaxY","seriesGetScaledGridSize","search","divider","gridValueSize","getScale","scale","toFixed","level","seriesHideClusteredData","oldPointsId","seriesIsValidGroupedDataObject","result","seriesPreventClusterCollisions","props","nextXPixel","nextYPixel","signX","signY","cornerGridX","cornerGridY","j","itemX","itemY","nextClusterPos","maxDist","split","parseFloat","gridXPx","gridYPx","propsPx","gridsToCheckCollision","xPixel","yPixel","gridsToCheckCollision_1","item","pos_1","projectedUnitsToPixels","compose","highchartsDefaultOptions","ScatterSeriesClass","scatterProto","prototype","generatePoints","animateClusterPoint","plotOptions","D","H","MarkerClusterScatter","defaultOptions","composed","pushUnique","onAxisSetExtremes","animationDuration","onChartRender","pinchDown","eventArgs","trigger","onDrillToCluster","events","onPointUpdate","dataGroup","onSeriesAfterRender","clusterZoomEnabled","addClass","css","cursor","AxisClass","ChartClass","SeriesClass","PointClass","pointClass","ScatterSeries","types","scatter","symbols","w","h","inner","arc","space","start","PI","end","open","outer1","innerR","outerWidth","outer2","concat","SVGRendererClass","MarkerClusters","MarkerClusterSymbols","G","Axis","Chart","Series","SVGRenderer"],"mappings":"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"}